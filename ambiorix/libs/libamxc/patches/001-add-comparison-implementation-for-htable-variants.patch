From 650bd11cb0f7dc4f9a5189859ba1a2b57222fab9 Mon Sep 17 00:00:00 2001
From: Alexander VAN PARYS <alexander.vanparys@softathome.com>
Date: Wed, 5 Oct 2022 08:28:29 +0200
Subject: [PATCH] Add comparison implementation for htable variants
 [new]

---
 src/variants/variant_htable.c             | 38 ++++++++++++-
 test/variant_htable/test_main.c           |  1 +
 test/variant_htable/test_variant_htable.c | 66 +++++++++++++++++++++++
 test/variant_htable/test_variant_htable.h |  3 +-
 4 files changed, 106 insertions(+), 2 deletions(-)

diff --git a/src/variants/variant_htable.c b/src/variants/variant_htable.c
index 3cdb327..23ef5b7 100644
--- a/src/variants/variant_htable.c
+++ b/src/variants/variant_htable.c
@@ -356,6 +356,42 @@ exit:
     return retval;
 }
 
+static int variant_htable_compare(const amxc_var_t* const lval,
+                                  const amxc_var_t* const rval,
+                                  int* const result) {
+    int ret = 0;
+    amxc_array_t* keys_l = amxc_htable_get_sorted_keys(amxc_var_constcast(amxc_htable_t, lval));
+    amxc_array_t* keys_r = amxc_htable_get_sorted_keys(amxc_var_constcast(amxc_htable_t, rval));
+    size_t size_l = amxc_array_size(keys_l);
+    size_t size_r = amxc_array_size(keys_r);
+
+    if(size_l > size_r) {
+        *result = 1;
+        goto exit;
+    } else if(size_l < size_r) {
+        *result = -1;
+        goto exit;
+    }
+
+    for(size_t i = 0; i < size_l; i++) {
+        const char* key_l = (const char*) amxc_array_get_data_at(keys_l, i);
+        const char* key_r = (const char*) amxc_array_get_data_at(keys_r, i);
+
+        *result = strcmp(key_l, key_r);
+        when_false(*result == 0, exit);
+
+        ret = amxc_var_compare(amxc_var_get_key(lval, key_l, AMXC_VAR_FLAG_DEFAULT),
+                               amxc_var_get_key(rval, key_r, AMXC_VAR_FLAG_DEFAULT),
+                               result);
+        when_false((ret == 0) && (*result == 0), exit);
+    }
+
+exit:
+    amxc_array_delete(&keys_l, NULL);
+    amxc_array_delete(&keys_r, NULL);
+    return ret;
+}
+
 static amxc_var_type_t amxc_variant_htable = {
     .init = variant_htable_init,
     .del = variant_htable_delete,
@@ -363,7 +399,7 @@ static amxc_var_type_t amxc_variant_htable = {
     .move = variant_htable_move,
     .convert_from = NULL,
     .convert_to = variant_htable_convert_to,
-    .compare = NULL,
+    .compare = variant_htable_compare,
     .get_key = variant_htable_get_key,
     .set_key = variant_htable_set_key,
     .get_index = variant_htable_get_index,
diff --git a/test/variant_htable/test_main.c b/test/variant_htable/test_main.c
index 4c48d7b..612e6f1 100644
--- a/test/variant_htable/test_main.c
+++ b/test/variant_htable/test_main.c
@@ -76,6 +76,7 @@ int main(void) {
         cmocka_unit_test(test_variant_htable_convert_to_string),
         cmocka_unit_test(test_variant_htable_convert_to_string_should_not_segfault),
         cmocka_unit_test(test_variant_htable_set_get),
+        cmocka_unit_test(test_variant_htable_compare),
         cmocka_unit_test(test_variant_htable_get_key),
         cmocka_unit_test(test_variant_htable_set_key),
         cmocka_unit_test(test_variant_htable_add_new),
diff --git a/test/variant_htable/test_variant_htable.c b/test/variant_htable/test_variant_htable.c
index d7c9693..cd17b29 100644
--- a/test/variant_htable/test_variant_htable.c
+++ b/test/variant_htable/test_variant_htable.c
@@ -346,6 +346,72 @@ void test_variant_htable_set_get(UNUSED void** state) {
     amxc_var_clean(&var);
 }
 
+void test_variant_htable_compare(UNUSED void** state) {
+    amxc_var_t var1;
+    amxc_var_t var2;
+    amxc_var_t data;
+    int result = 0;
+
+    assert_int_equal(amxc_var_init(&var1), 0);
+    assert_int_equal(amxc_var_init(&var2), 0);
+    assert_int_equal(amxc_var_init(&data), 0);
+    assert_int_equal(amxc_var_set_type(&var1, AMXC_VAR_ID_HTABLE), 0);
+    assert_int_equal(var1.type_id, AMXC_VAR_ID_HTABLE);
+    assert_int_equal(amxc_var_set_type(&var2, AMXC_VAR_ID_HTABLE), 0);
+    assert_int_equal(var2.type_id, AMXC_VAR_ID_HTABLE);
+
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result == 0);
+
+    assert_non_null(amxc_var_add_key(cstring_t, &var1, "cstring_key", "my_value"));
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result > 0);
+    assert_int_equal(amxc_var_compare(&var2, &var1, &result), 0);
+    assert_true(result < 0);
+
+    assert_non_null(amxc_var_add_key(cstring_t, &var2, "cstring_key", "my_value"));
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result == 0);
+
+    assert_non_null(amxc_var_add_key(uint32_t, &var1, "uint32_key", 1));
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result > 0);
+
+    assert_non_null(amxc_var_add_key(uint32_t, &var2, "uint32_key", 2));
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result < 0);
+
+    assert_int_equal(amxc_var_set_type(&var1, AMXC_VAR_ID_HTABLE), 0);
+    assert_int_equal(amxc_var_set_type(&var2, AMXC_VAR_ID_HTABLE), 0);
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result == 0);
+
+    assert_int_equal(amxc_var_set(cstring_t, &data, "value"), 0);
+    assert_int_equal(amxc_var_set_path(&var1, "table_1.2.table_2.my_string", &data,
+                                       AMXC_VAR_FLAG_AUTO_ADD | AMXC_VAR_FLAG_COPY), 0);
+    assert_int_equal(amxc_var_set_path(&var2, "table_1.2.table_2.my_string", &data,
+                                       AMXC_VAR_FLAG_AUTO_ADD | AMXC_VAR_FLAG_COPY), 0);
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result == 0);
+
+    assert_int_equal(amxc_var_set_type(&var1, AMXC_VAR_ID_HTABLE), 0);
+    assert_int_equal(amxc_var_set_type(&var2, AMXC_VAR_ID_HTABLE), 0);
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result == 0);
+
+    assert_non_null(amxc_var_add_key(cstring_t, &var1, "key", "my_value"));
+    assert_non_null(amxc_var_add_key(uint32_t, &var2, "key", 2));
+    assert_int_equal(amxc_var_compare(&var1, &var2, &result), 0);
+    assert_true(result != 0);
+
+    assert_int_equal(amxc_var_compare(&var1, &data, &result), 0);
+    assert_true(result != 0);
+
+    amxc_var_clean(&var1);
+    amxc_var_clean(&var2);
+    amxc_var_clean(&data);
+}
+
 void test_variant_htable_add_new(UNUSED void** state) {
     amxc_var_t var;
     amxc_var_t* item = NULL;
diff --git a/test/variant_htable/test_variant_htable.h b/test/variant_htable/test_variant_htable.h
index 27cc943..5038962 100644
--- a/test/variant_htable/test_variant_htable.h
+++ b/test/variant_htable/test_variant_htable.h
@@ -70,6 +70,7 @@ void test_variant_htable_convert_to_list(void** state);
 void test_variant_htable_convert_to_string(void** state);
 void test_variant_htable_convert_to_string_should_not_segfault(void** state);
 void test_variant_htable_set_get(void** state);
+void test_variant_htable_compare(void** state);
 
 void test_variant_htable_get_key(void** state);
 void test_variant_htable_set_key(void** state);
@@ -77,4 +78,4 @@ void test_variant_htable_add_new(void** state);
 void test_variant_htable_add_new_key(void** state);
 void test_variant_htable_add_new_key_duplicate(void** state);
 
-#endif // __TEST_VARIANT_HTABLE_H__
\ No newline at end of file
+#endif // __TEST_VARIANT_HTABLE_H__
-- 
GitLab
